---
// Terminal component with integrated BIOS boot sequence
import '@xterm/xterm/css/xterm.css';
---

<div id="terminal" class="terminal-container fullscreen-terminal">
  <div class="loading-message">Initializing system...</div>
</div>

<script>
  console.log('Terminal script starting...');
  
  // Constants
  const TERMINAL_CONFIG = {
    CURSOR_BLINK_RATE: 500,
    FONT_SIZE: 22,
    FONT_FAMILY: 'Monaco, Menlo, "Ubuntu Mono", monospace',
    COLS: 100,
    ROWS: 30,
    THEME: {
      background: 'transparent',
      foreground: '#00ffff',
      cursor: '#00ffff',
      selection: '#00ffff30',
      brightWhite: '#ffffff',
      brightCyan: '#00ffff',
      brightGreen: '#00ff00',
      brightMagenta: '#ff00ff',
      brightYellow: '#ffff00',
    }
  };

  const MOBILE_CONFIG = {
    TYPE_DELAY_MOBILE: 15,
    TYPE_DELAY_DESKTOP: 25,
    GLITCH_INTERVAL: 3000,
    GLITCH_PROBABILITY: 0.02,
    MOBILE_REGEX: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i
  };

  const COLOR_CODES = {
    BRIGHT_CYAN: '\x1b[96m',
    BRIGHT_GREEN: '\x1b[92m',
    BRIGHT_MAGENTA: '\x1b[95m',
    BRIGHT_BLUE: '\x1b[94m',
    BRIGHT_YELLOW: '\x1b[93m',
    BRIGHT_RED: '\x1b[91m',
    BRIGHT_WHITE: '\x1b[97m',
    RESET: '\x1b[0m',
    DIM_WHITE: '\x1b[90m'
  };

  const BOOT_MESSAGES = [
    { text: 'BIOS v2.1.7 - Cyber Systems Inc.', color: COLOR_CODES.BRIGHT_CYAN, delay: 0 },
    { text: 'Copyright (c) 2024 Cyber Systems', color: COLOR_CODES.BRIGHT_CYAN, delay: 200 },
    { text: '', delay: 100 },
    { text: 'CPU: Quantum Processor X9 @ 4.2GHz', color: COLOR_CODES.BRIGHT_MAGENTA, delay: 300 },
    { text: 'CPU Test: [OK]', color: COLOR_CODES.BRIGHT_GREEN, delay: 800 },
    { text: '', delay: 200 },
    { text: 'Memory: 32768MB DDR7', color: COLOR_CODES.BRIGHT_MAGENTA, delay: 300 },
    { text: 'Memory Test: ', color: COLOR_CODES.BRIGHT_MAGENTA, delay: 600 },
    { text: '████████████████████', color: COLOR_CODES.BRIGHT_GREEN, delay: 900, instant: true },
    { text: '[OK]', color: COLOR_CODES.BRIGHT_GREEN, delay: 100 },
    { text: '', delay: 200 },
    { text: 'Initializing System Modules...', color: COLOR_CODES.BRIGHT_BLUE, delay: 300 },
    { text: 'Loading kernel.sys', color: COLOR_CODES.BRIGHT_CYAN, delay: 600 },
    { text: 'Loading drivers.dll', color: COLOR_CODES.BRIGHT_CYAN, delay: 900 },
    { text: 'Loading network.stack', color: COLOR_CODES.BRIGHT_CYAN, delay: 1200 },
    { text: 'Loading security.module', color: COLOR_CODES.BRIGHT_CYAN, delay: 1500 },
    { text: 'System Modules: [OK]', color: COLOR_CODES.BRIGHT_GREEN, delay: 1800 },
    { text: '', delay: 200 },
    { text: 'Checking Hardware...', color: COLOR_CODES.BRIGHT_BLUE, delay: 300 },
    { text: 'HDD0: CyberDrive SSD 2TB [OK]', color: COLOR_CODES.BRIGHT_GREEN, delay: 600 },
    { text: 'GPU: NeonGraphics RTX 9090 [OK]', color: COLOR_CODES.BRIGHT_GREEN, delay: 900 },
    { text: 'NET: CyberLink 10GbE [OK]', color: COLOR_CODES.BRIGHT_GREEN, delay: 1200 },
    { text: '', delay: 300 },
    { text: 'System Check Complete', color: COLOR_CODES.BRIGHT_GREEN, delay: 400 },
    { text: 'All systems operational', color: COLOR_CODES.BRIGHT_CYAN, delay: 700 },
    { text: '', delay: 500 },
    { text: 'Starting interactive terminal...', color: COLOR_CODES.BRIGHT_GREEN, delay: 800 },
    { text: '', delay: 1000 }
  ];

  const GLITCH_TYPES = ['flicker', 'shift', 'color'];

  // Utility functions
  function isMobile() {
    return MOBILE_CONFIG.MOBILE_REGEX.test(navigator.userAgent);
  }

  function createError(message) {
    return new Error(`Terminal Error: ${message}`);
  }

  function manageTimeouts() {
    const timeoutIds = [];
    
    return {
      add: (id) => timeoutIds.push(id),
      clearAll: () => {
        timeoutIds.forEach(id => clearTimeout(id));
        timeoutIds.length = 0;
      },
      getCount: () => timeoutIds.length
    };
  }

  // Initialize terminal when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM loaded, initializing terminal...');
    initTerminalWithBoot();
  });

  function handleAsyncError(error, fallbackMessage) {
    console.error(error);
    showError(fallbackMessage);
  }

  function initTerminalWithBoot() {
    try {
      console.log('Creating terminal with boot sequence...');

      // Load xterm and web links addon from npm package
      Promise.all([
        import('@xterm/xterm'),
        import('@xterm/addon-web-links')
      ]).then(([{ Terminal }, { WebLinksAddon }]) => {
        console.log('xterm and addons loaded, creating terminal instance');
        createTerminalWithBoot(Terminal, WebLinksAddon);
      }).catch(err => {
        handleAsyncError(err, 'Failed to load terminal library');
        loadFromCDN();
      });

    } catch (error) {
      handleAsyncError(error, 'Error initializing terminal');
    }
  }

  function loadFromCDN() {
    console.log('Loading xterm from CDN...');
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/lib/xterm.js';
    script.onload = () => {
      console.log('xterm loaded from CDN');
      createTerminalWithBoot(window.Terminal, null);
    };
    script.onerror = () => {
      handleAsyncError('Failed to load xterm from CDN', 'Failed to load terminal library');
    };
    document.head.appendChild(script);
  }

  function createTerminalInstance(Terminal) {
    return new Terminal({
      cursorBlink: true,
      cursorBlinkRate: TERMINAL_CONFIG.CURSOR_BLINK_RATE,
      fontSize: TERMINAL_CONFIG.FONT_SIZE,
      fontFamily: TERMINAL_CONFIG.FONT_FAMILY,
      theme: TERMINAL_CONFIG.THEME,
      cols: TERMINAL_CONFIG.COLS,
      rows: TERMINAL_CONFIG.ROWS,
      allowTransparency: true,
    });
  }

  function setupWebLinks(terminal, WebLinksAddon) {
    if (WebLinksAddon) {
      const webLinksAddon = new WebLinksAddon();
      terminal.loadAddon(webLinksAddon);
      console.log('WebLinksAddon loaded - URLs are now clickable');
    }
  }

  function createCRTEffectsContainer(terminalContainer) {
    const crtEffects = document.createElement('div');
    crtEffects.className = 'terminal-crt-effects';
    terminalContainer.appendChild(crtEffects);
    return crtEffects;
  }

  function initializeTerminalState() {
    return {
      currentLine: '',
      history: [],
      historyIndex: -1,
      prompt: '$ ',
      bootComplete: false
    };
  }

  function createTerminalWithBoot(Terminal, WebLinksAddon) {
    try {
      console.log('Creating terminal with boot sequence...');

      const terminalContainer = document.getElementById('terminal');
      if (!terminalContainer) {
        throw createError('Terminal container not found');
      }

      // Clear loading message and set fullscreen mode
      terminalContainer.innerHTML = '';
      terminalContainer.classList.add('fullscreen-mode');

      // Create and configure terminal
      const terminal = createTerminalInstance(Terminal);
      terminal.open(terminalContainer);

      // Setup web links addon
      setupWebLinks(terminal, WebLinksAddon);

      // Create CRT effects
      createCRTEffectsContainer(terminalContainer);
      
      // Initialize terminal state
      const state = initializeTerminalState();
      
      // Initialize CRT effects
      initCRTEffects(terminalContainer);

      // Load commands and start boot sequence
      loadCommands().then(() => {
        runBIOSBootSequence(terminal, () => {
          state.bootComplete = true;
          setupInteractiveTerminal(terminal, state.currentLine, state.history, state.historyIndex, state.prompt);
        });
      }).catch(err => {
        handleAsyncError(err, 'Failed to load terminal commands');
      });

      console.log('Terminal with boot sequence initialized successfully');
      
    } catch (error) {
      console.error('Error creating terminal:', error);
      showError('Error creating terminal: ' + error.message);
    }
  }

  function createSkipHandler(terminal, prompt, callback, timeoutManager) {
    return () => {
      timeoutManager.clearAll();
      terminal.clear();
      showWelcomeMessage(terminal, prompt);
      callback();
    };
  }

  function typeWriter(terminal, text, color, callback, timeoutManager) {
    const typeDelay = isMobile() ? MOBILE_CONFIG.TYPE_DELAY_MOBILE : MOBILE_CONFIG.TYPE_DELAY_DESKTOP;
    let charIndex = 0;
    
    function typeChar() {
      if (charIndex < text.length) {
        terminal.write(`${color}${text[charIndex]}${COLOR_CODES.RESET}`);
        charIndex++;
        const charTimeoutId = setTimeout(typeChar, typeDelay);
        timeoutManager.add(charTimeoutId);
      } else {
        callback();
      }
    }
    
    typeChar();
  }

  function processBootMessage(terminal, message, prompt, callback, timeoutManager, messageIndex, bootMessages) {
    const msgTimeoutId = setTimeout(() => {
      if (message.text) {
        if (message.instant) {
          terminal.writeln(`${message.color}${message.text}${COLOR_CODES.RESET}`);
        } else {
          typeWriter(terminal, message.text, message.color, () => {
            terminal.writeln('');
            messageIndex++;
            processNextBootMessage(terminal, prompt, callback, timeoutManager, messageIndex, bootMessages);
          }, timeoutManager);
          return;
        }
      } else {
        terminal.writeln('');
      }

      messageIndex++;
      processNextBootMessage(terminal, prompt, callback, timeoutManager, messageIndex, bootMessages);
    }, message.delay);
    timeoutManager.add(msgTimeoutId);
  }

  function processNextBootMessage(terminal, prompt, callback, timeoutManager, messageIndex, bootMessages) {
    if (messageIndex >= bootMessages.length) {
      terminal.clear();
      showWelcomeMessage(terminal, prompt);
      callback();
      return;
    }

    const message = bootMessages[messageIndex];
    processBootMessage(terminal, message, prompt, callback, timeoutManager, messageIndex, bootMessages);
  }

  function runBIOSBootSequence(terminal, callback) {
    const timeoutManager = manageTimeouts();
    const skipHandler = createSkipHandler(terminal, '$ ', callback, timeoutManager);

    // Attach skip listener (auto-removes after first keypress)
    document.addEventListener('keydown', skipHandler, { once: true });

    // Start the boot sequence
    const initialTimeoutId = setTimeout(() => {
      processNextBootMessage(terminal, '$ ', callback, timeoutManager, 0, BOOT_MESSAGES);
    }, 500);
    timeoutManager.add(initialTimeoutId);
  }

  function showWelcomeMessage(terminal, prompt) {
    terminal.writeln('\x1b[96mWelcome to the Interactive Terminal!\x1b[0m');
    terminal.writeln('Type "help" for available commands.');
    terminal.writeln('');
    terminal.write(prompt);
  }

  // Load command registry
  let commandRegistry;
  let commandNames;

  async function loadCommands() {
    const { getCommandRegistry, getCommandNames } = await import('../commands/index');
    commandRegistry = getCommandRegistry();
    commandNames = getCommandNames();
  }

  function handleEnterKey(terminal, currentLine, history, historyIndex, prompt, commandRunning) {
    terminal.write('\r\n');

    if (currentLine.trim()) {
      history.push(currentLine);
      historyIndex = -1;
    }

    const commandInput = currentLine.trim();
    const [cmd, ...args] = commandInput.split(' ');

    currentLine = '';

    if (cmd === '') {
      terminal.write(prompt);
      return { currentLine, commandRunning: false };
    }

    return executeCommand(terminal, cmd, args, prompt, commandRunning);
  }

  function executeCommand(terminal, cmd, args, prompt, commandRunning) {
    const command = commandRegistry.get(cmd);
    if (command) {
      try {
        const context = {
          terminal,
          args,
          onComplete: () => {
            commandRunning = false;
            terminal.write(prompt);
          }
        };

        const result = command.execute(context);

        if (result instanceof Promise) {
          commandRunning = true;
          result.catch(err => {
            console.error(`Error executing command ${cmd}:`, err);
            terminal.writeln(`${COLOR_CODES.BRIGHT_RED}Error executing command${COLOR_CODES.RESET}`);
            commandRunning = false;
            terminal.write(prompt);
          });
        } else {
          terminal.write(prompt);
        }
      } catch (err) {
        console.error(`Error executing command ${cmd}:`, err);
        terminal.writeln(`${COLOR_CODES.BRIGHT_RED}Error executing command${COLOR_CODES.RESET}`);
        terminal.write(prompt);
      }
    } else {
      terminal.writeln(`${COLOR_CODES.BRIGHT_RED}Command not found: ${cmd}${COLOR_CODES.RESET}`);
      terminal.writeln(`${COLOR_CODES.DIM_WHITE}Type "help" for available commands.${COLOR_CODES.RESET}`);
      terminal.write(prompt);
    }

    return { currentLine: '', commandRunning };
  }

  function handleBackspace(terminal, currentLine) {
    if (currentLine.length > 0) {
      currentLine = currentLine.slice(0, -1);
      terminal.write('\b \b');
    }
    return currentLine;
  }

  function handleUpArrow(terminal, history, historyIndex, prompt) {
    if (historyIndex < history.length - 1) {
      historyIndex++;
      const cmd = history[history.length - 1 - historyIndex];
      terminal.write('\r\x1b[K' + prompt + cmd);
      return { currentLine: cmd, historyIndex };
    }
    return { currentLine: '', historyIndex };
  }

  function handleDownArrow(terminal, history, historyIndex, prompt) {
    if (historyIndex > -1) {
      historyIndex--;
      if (historyIndex === -1) {
        terminal.write('\r\x1b[K' + prompt);
        return { currentLine: '', historyIndex };
      } else {
        const cmd = history[history.length - 1 - historyIndex];
        terminal.write('\r\x1b[K' + prompt + cmd);
        return { currentLine: cmd, historyIndex };
      }
    }
    return { currentLine: '', historyIndex };
  }

  function handleTabAutocomplete(terminal, currentLine, prompt) {
    const input = currentLine.trim();

    if (input) {
      const matches = commandNames.filter(cmd => cmd.startsWith(input));
      if (matches.length === 1) {
        const completion = matches[0].slice(input.length);
        currentLine += completion;
        terminal.write(completion);
      } else if (matches.length > 1) {
        terminal.write('\r\n');
        matches.forEach(cmd => terminal.writeln(`  ${COLOR_CODES.BRIGHT_YELLOW}${cmd}${COLOR_CODES.RESET}`));
        terminal.write(prompt + currentLine);
      }
    }
    return currentLine;
  }

  function handleDefaultInput(terminal, data, currentLine) {
    if (data >= ' ' && data <= '~') {
      currentLine += data;
      terminal.write(data);
    }
    return currentLine;
  }

  function setupInteractiveTerminal(terminal, currentLine, history, historyIndex, prompt) {
    let commandRunning = false;

    terminal.onData((data) => {
      if (commandRunning) return;

      switch (data) {
        case '\r': // Enter
          const enterResult = handleEnterKey(terminal, currentLine, history, historyIndex, prompt, commandRunning);
          currentLine = enterResult.currentLine;
          commandRunning = enterResult.commandRunning;
          break;
          
        case '\u007F': // Backspace
          currentLine = handleBackspace(terminal, currentLine);
          break;
          
        case '\u001b[A': // Up arrow
          const arrowResult = handleUpArrow(terminal, history, historyIndex, prompt);
          currentLine = arrowResult.currentLine;
          historyIndex = arrowResult.historyIndex;
          break;
          
        case '\u001b[B': // Down arrow
          const downResult = handleDownArrow(terminal, history, historyIndex, prompt);
          currentLine = downResult.currentLine;
          historyIndex = downResult.historyIndex;
          break;
          
        case '\t': // Tab autocomplete
          currentLine = handleTabAutocomplete(terminal, currentLine, prompt);
          break;
          
        default:
          currentLine = handleDefaultInput(terminal, data, currentLine);
      }
    });
  }

  // CRT Effects Implementation
  function initCRTEffects(container) {
    if (!isMobile()) {
      startRandomGlitches(container);
      enhanceCursorBlink(container);
    }
  }

  function startRandomGlitches(container) {
    const glitchInterval = setInterval(() => {
      if (Math.random() < MOBILE_CONFIG.GLITCH_PROBABILITY) {
        triggerGlitch(container);
      }
    }, MOBILE_CONFIG.GLITCH_INTERVAL);
    
    // Store interval ID for potential cleanup
    container.glitchInterval = glitchInterval;
  }

  function triggerGlitch(container) {
    const glitchType = GLITCH_TYPES[Math.floor(Math.random() * GLITCH_TYPES.length)];
    
    switch (glitchType) {
      case 'flicker':
        container.style.opacity = '0.95';
        setTimeout(() => {
          container.style.opacity = '1';
        }, 50);
        break;
        
      case 'shift':
        container.style.transform = `translate(${Math.random() * 2 - 1}px, ${Math.random() * 2 - 1}px)`;
        setTimeout(() => {
          container.style.transform = 'translate(0, 0)';
        }, 100);
        break;
        
      case 'color':
        const originalFilter = container.style.filter;
        container.style.filter = 'hue-rotate(90deg) saturate(1.5)';
        setTimeout(() => {
          container.style.filter = originalFilter;
        }, 75);
        break;
    }
  }

  function enhanceCursorBlink(container) {
    // Add enhanced cursor glow effect
    const style = document.createElement('style');
    style.textContent = `
      .terminal-crt-effects {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 10;
      }
      
      .xterm-cursor {
        box-shadow: 0 0 8px #00ffff, 0 0 16px rgba(0, 255, 255, 0.8);
        animation: cursorGlow 2s ease-in-out infinite alternate;
      }
      
      @keyframes cursorGlow {
        0% { box-shadow: 0 0 8px #00ffff, 0 0 16px rgba(0, 255, 255, 0.8); }
        100% { box-shadow: 0 0 12px #00ffff, 0 0 24px rgba(0, 255, 255, 1); }
      }
      
      @keyframes terminalScanline {
        0% { transform: translateY(0); }
        100% { transform: translateY(10px); }
      }
      
      .xterm-screen {
        position: relative;
      }
      
      .xterm-screen::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          0deg,
          transparent 0%,
          rgba(34, 233, 216, 0.01) 50%,
          transparent 100%
        );
        pointer-events: none;
        animation: terminalScanline 8s linear infinite;
      }
    `;
    document.head.appendChild(style);
  }

  function showError(message) {
    const terminalContainer = document.getElementById('terminal');
    if (terminalContainer) {
      // Clear any existing intervals
      if (terminalContainer.glitchInterval) {
        clearInterval(terminalContainer.glitchInterval);
      }
      terminalContainer.innerHTML = `<div class="error-message">${message}</div>`;
    }
  }

  // Cleanup function to be called when component is destroyed
  function cleanup() {
    const terminalContainer = document.getElementById('terminal');
    if (terminalContainer && terminalContainer.glitchInterval) {
      clearInterval(terminalContainer.glitchInterval);
    }
  }

  // Add cleanup on page unload
  window.addEventListener('beforeunload', cleanup);
</script>

<style>
  .terminal-container {
    width: 100%;
    height: 100vh;
    background: transparent;
    border-radius: 0;
    padding: 40px;
    position: fixed;
    top: 0;
    left: 0;
    z-index: 9998;
    transition: all 0.1s ease;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .terminal-container :global(.xterm) {
    background: #000;
    /* Smooth squircle-like border radius for authentic CRT appearance */
    border-radius: 3% / 2.5%;
    overflow: hidden;
    height: calc(100vh - 80px) !important;
    width: calc(100% - 80px) !important;
    padding: 20px;
    font-size: 18px;
    box-shadow:
      inset 0 0 120px rgba(0, 0, 0, 0.9),
      inset 0 0 40px rgba(0, 0, 0, 0.7),
      0 0 80px rgba(34, 233, 216, 0.3),
      0 0 120px rgba(227, 72, 128, 0.2);
    position: relative;
    transform-style: preserve-3d;
  }

  /* CRT Screen Curvature - Convex Bulge Effect with vignetting */
  .terminal-container :global(.xterm)::before {
    content: '';
    position: absolute;
    top: -5%;
    left: -5%;
    width: 110%;
    height: 110%;
    background: radial-gradient(
      ellipse at center,
      transparent 0%,
      transparent 50%,
      rgba(0, 0, 0, 0.15) 70%,
      rgba(0, 0, 0, 0.4) 85%,
      rgba(0, 0, 0, 0.7) 100%
    );
    pointer-events: none;
    z-index: 100;
    border-radius: inherit;
  }

  /* Glass reflection overlay */
  .terminal-container :global(.xterm)::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background:
      radial-gradient(
        ellipse 800px 600px at 20% 15%,
        rgba(255, 255, 255, 0.15) 0%,
        rgba(255, 255, 255, 0.08) 20%,
        transparent 40%
      ),
      radial-gradient(
        ellipse 400px 300px at 80% 80%,
        rgba(255, 255, 255, 0.08) 0%,
        rgba(255, 255, 255, 0.03) 30%,
        transparent 50%
      ),
      linear-gradient(
        180deg,
        rgba(255, 255, 255, 0.05) 0%,
        transparent 50%,
        rgba(0, 0, 0, 0.1) 100%
      );
    pointer-events: none;
    z-index: 99;
    border-radius: inherit;
    mix-blend-mode: overlay;
  }

  .terminal-container :global(.xterm-viewport) {
    transform:
      perspective(2000px)
      rotateX(-2deg)
      scale3d(0.98, 0.96, 1);
    transform-style: preserve-3d;
    transform-origin: center center;
    border-radius: inherit;
    clip-path:
      ellipse(
        calc(50% - 10px) calc(50% - 10px)
        at 50% 50%
      );
  }

  /* Text curvature to follow screen bulge */
  .terminal-container :global(.xterm-rows) {
    transform:
      perspective(1500px)
      rotateX(1.5deg)
      scale3d(1.02, 1.02, 1);
    transform-style: preserve-3d;
    transform-origin: center center;
  }

  /* Individual row curvature for barrel distortion effect */
  .terminal-container :global(.xterm-rows > div) {
    transform-style: preserve-3d;
  }

  /* Top rows curve backward slightly */
  .terminal-container :global(.xterm-rows > div:nth-child(-n+5)) {
    transform: scaleX(0.99) translateZ(-2px);
  }

  /* Middle rows are neutral (screen center) */
  .terminal-container :global(.xterm-rows > div:nth-child(n+6):nth-child(-n+25)) {
    transform: scaleX(1.0) translateZ(0px);
  }

  /* Bottom rows curve backward */
  .terminal-container :global(.xterm-rows > div:nth-child(n+26)) {
    transform: scaleX(0.99) translateZ(-2px);
  }

  /* Phosphor glow distribution following curvature */
  .terminal-container :global(.xterm-screen) {
    filter:
      drop-shadow(0 0 1px rgba(0, 255, 255, 0.3))
      drop-shadow(0 0 2px rgba(0, 255, 255, 0.2));
  }

  /* Scrollbar curvature to match CRT convex effect */
  .terminal-container :global(.xterm-viewport)::-webkit-scrollbar {
    width: 14px;
    transform-style: preserve-3d;
  }

  .terminal-container :global(.xterm-viewport)::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.3);
    border-radius: 10px;
    margin: 10px 0;
    transform:
      perspective(1000px)
      rotateY(-2deg)
      translateZ(-5px);
    transform-style: preserve-3d;
    box-shadow:
      inset 2px 0 8px rgba(0, 0, 0, 0.5),
      inset -1px 0 4px rgba(34, 233, 216, 0.1);
  }

  .terminal-container :global(.xterm-viewport)::-webkit-scrollbar-thumb {
    background: linear-gradient(
      180deg,
      rgba(34, 233, 216, 0.4) 0%,
      rgba(34, 233, 216, 0.6) 50%,
      rgba(34, 233, 216, 0.4) 100%
    );
    border-radius: 10px;
    border: 2px solid rgba(0, 0, 0, 0.5);
    transform:
      perspective(1000px)
      rotateY(-2deg)
      translateZ(-3px)
      scaleX(0.95);
    transform-style: preserve-3d;
    box-shadow:
      0 0 8px rgba(34, 233, 216, 0.4),
      inset 0 0 4px rgba(34, 233, 216, 0.3),
      inset 1px 0 2px rgba(255, 255, 255, 0.2);
  }

  .terminal-container :global(.xterm-viewport)::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(
      180deg,
      rgba(34, 233, 216, 0.6) 0%,
      rgba(34, 233, 216, 0.8) 50%,
      rgba(34, 233, 216, 0.6) 100%
    );
    box-shadow:
      0 0 12px rgba(34, 233, 216, 0.6),
      inset 0 0 6px rgba(34, 233, 216, 0.5),
      inset 1px 0 3px rgba(255, 255, 255, 0.3);
  }

  /* Scrollbar container wrapper with curvature */
  .terminal-container :global(.xterm-viewport) {
    scrollbar-width: thin;
    scrollbar-color: rgba(34, 233, 216, 0.5) rgba(0, 0, 0, 0.3);
  }

  /* Apply subtle barrel distortion to scrollbar area */
  .terminal-container :global(.xterm-viewport)::after {
    content: '';
    position: absolute;
    top: 0;
    right: 0;
    width: 20px;
    height: 100%;
    background: radial-gradient(
      ellipse at right center,
      transparent 0%,
      rgba(0, 0, 0, 0.1) 70%,
      rgba(0, 0, 0, 0.2) 100%
    );
    pointer-events: none;
    z-index: 1000;
    transform:
      perspective(800px)
      rotateY(-3deg)
      translateZ(-10px);
    transform-style: preserve-3d;
  }

  .loading-message, .error-message {
    color: #00ff00;
    padding: 20px;
    font-family: monospace;
    text-align: center;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  }

  .error-message {
    color: #ff0000;
  }

  :global(.xterm-viewport) {
    background-color: transparent !important;
  }

  :global(.xterm-screen) {
    background-color: transparent !important;
  }

  /* Fullscreen terminal mode */
  .fullscreen-terminal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 9998;
  }

  /* Mobile optimizations */
  @media (max-width: 768px) {
    .terminal-container {
      padding: 20px;
    }

    .terminal-container :global(.xterm) {
      height: calc(100vh - 40px) !important;
      width: calc(100% - 40px) !important;
      border-radius: 2.5% / 2%;
      padding: 15px;
      font-size: 14px;
    }

    /* Reduce curvature intensity on mobile for readability */
    .terminal-container :global(.xterm-viewport) {
      transform:
        perspective(1500px)
        rotateX(-1deg)
        scale3d(0.99, 0.98, 1);
    }

    .terminal-container :global(.xterm-rows) {
      transform:
        perspective(1200px)
        rotateX(1deg)
        scale3d(1.01, 1.01, 1);
    }

    /* Reduce glass reflection on mobile */
    .terminal-container :global(.xterm)::after {
      opacity: 0.5;
    }

    /* Reduce edge vignetting on mobile */
    .terminal-container :global(.xterm)::before {
      opacity: 0.6;
    }

    /* Reduce scrollbar curvature on mobile */
    .terminal-container :global(.xterm-viewport)::-webkit-scrollbar {
      width: 10px;
    }

    .terminal-container :global(.xterm-viewport)::-webkit-scrollbar-track {
      transform:
        perspective(800px)
        rotateY(-1deg)
        translateZ(-3px);
    }

    .terminal-container :global(.xterm-viewport)::-webkit-scrollbar-thumb {
      transform:
        perspective(800px)
        rotateY(-1deg)
        translateZ(-2px)
        scaleX(0.97);
    }

    .terminal-container :global(.xterm-viewport)::after {
      transform:
        perspective(600px)
        rotateY(-2deg)
        translateZ(-5px);
    }
  }
</style>
