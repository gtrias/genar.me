---
// Convex screen effect using Three.js
// Creates a curved CRT-like display with terminal content
---

<div id="convex-screen-container" class="convex-screen-container">
  <canvas id="convex-screen-canvas"></canvas>
</div>

<script>
  import * as THREE from 'three';

  class ConvexScreenEffect {
    constructor() {
      this.scene = null;
      this.camera = null;
      this.renderer = null;
      this.screenMesh = null;
      this.terminalTexture = null;
      this.animationId = null;
      this.terminalElement = null;
      this.renderCanvas = null;
      this.renderContext = null;
    }

    init() {
      this.setupScene();
      this.setupCamera();
      this.setupRenderer();
      this.setupScreen();
      this.setupTerminalCapture();
      this.animate();
    }

    setupScene() {
      this.scene = new THREE.Scene();
      this.scene.background = new THREE.Color(0x000000);
    }

    setupCamera() {
      const aspect = window.innerWidth / window.innerHeight;
      this.camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
      this.camera.position.z = 2;
    }

    setupRenderer() {
      const canvas = document.getElementById('convex-screen-canvas');
      this.renderer = new THREE.WebGLRenderer({ 
        canvas, 
        antialias: true,
        alpha: true 
      });
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.renderer.setPixelRatio(window.devicePixelRatio);
    }

    setupScreen() {
      // Create curved cylinder geometry for convex effect
      const geometry = new THREE.CylinderGeometry(1.5, 1.5, 1, 32, 1, true, 0, Math.PI);
      
      // Custom shader material for convex curvature and CRT effects
      const material = new THREE.ShaderMaterial({
        uniforms: {
          terminalTexture: { value: null },
          time: { value: 0 },
          curvature: { value: 0.3 },
          scanlineIntensity: { value: 0.1 },
          glowIntensity: { value: 0.05 }
        },
        vertexShader: `
          varying vec2 vUv;
          varying vec3 vPosition;
          
          void main() {
            vUv = uv;
            vPosition = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D terminalTexture;
          uniform float time;
          uniform float curvature;
          uniform float scanlineIntensity;
          uniform float glowIntensity;
          
          varying vec2 vUv;
          varying vec3 vPosition;
          
          void main() {
            vec2 uv = vUv;
            
            // Apply convex curvature distortion
            float dist = distance(uv, vec2(0.5, 0.5));
            uv -= 0.5;
            uv *= 1.0 + curvature * dist * dist;
            uv += 0.5;
            
            // Sample terminal texture
            vec4 texel = texture2D(terminalTexture, uv);
            
            // Add scanlines
            float scanline = sin(uv.y * 800.0 + time * 10.0) * 0.5 + 0.5;
            texel.rgb *= 1.0 - scanlineIntensity * (1.0 - scanline);
            
            // Add phosphor glow
            float glow = sin(time * 15.0 + uv.x * 20.0) * 0.5 + 0.5;
            texel.rgb += glowIntensity * glow * texel.rgb;
            
            // Add slight color shift for CRT effect
            texel.r = mix(texel.r, texel.g, 0.02);
            texel.b = mix(texel.b, texel.g, 0.02);
            
            gl_FragColor = texel;
          }
        `,
        transparent: true,
        side: THREE.DoubleSide
      });

      this.screenMesh = new THREE.Mesh(geometry, material);
      this.scene.add(this.screenMesh);
    }

    setupTerminalCapture() {
      // Find the terminal element
      this.terminalElement = document.querySelector('.terminal-wrapper');
      if (!this.terminalElement) return;

      // Create hidden canvas for terminal rendering
      this.renderCanvas = document.createElement('canvas');
      this.renderCanvas.width = 1024;
      this.renderCanvas.height = 768;
      this.renderContext = this.renderCanvas.getContext('2d');
      
      // Create texture from canvas
      this.terminalTexture = new THREE.CanvasTexture(this.renderCanvas);
      this.terminalTexture.minFilter = THREE.LinearFilter;
      this.terminalTexture.magFilter = THREE.LinearFilter;
      
      // Update material uniform
      this.screenMesh.material.uniforms.terminalTexture.value = this.terminalTexture;
    }

    async captureTerminal() {
      if (!this.terminalElement || !this.renderContext) return;

      try {
        // Import html2canvas dynamically
        const html2canvas = (await import('html2canvas')).default;
        
        // Capture terminal element
        const canvas = await html2canvas(this.terminalElement, {
          backgroundColor: '#000000',
          scale: 1,
          logging: false,
          useCORS: true,
          allowTaint: true
        });

        // Draw captured content to our render canvas
        const ctx = this.renderContext;
        ctx.clearRect(0, 0, this.renderCanvas.width, this.renderCanvas.height);
        
        // Scale and center the captured terminal
        const scale = Math.min(
          this.renderCanvas.width / canvas.width,
          this.renderCanvas.height / canvas.height
        ) * 0.9;
        
        const x = (this.renderCanvas.width - canvas.width * scale) / 2;
        const y = (this.renderCanvas.height - canvas.height * scale) / 2;
        
        ctx.drawImage(canvas, x, y, canvas.width * scale, canvas.height * scale);

        // Update texture
        this.terminalTexture.needsUpdate = true;
      } catch (error) {
        console.warn('Terminal capture failed, using fallback:', error);
        this.captureTerminalFallback();
      }
    }

    captureTerminalFallback() {
      // Fallback method if html2canvas fails
      const ctx = this.renderContext;
      const width = this.renderCanvas.width;
      const height = this.renderCanvas.height;

      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, width, height);

      ctx.fillStyle = '#00ff00';
      ctx.font = '16px monospace';
      
      const sampleText = [
        'genar@terminal:~$ ls -la',
        'total 42',
        'drwxr-xr-x  12 genar  staff   384 Nov 18 10:30 .',
        'drwxr-xr-x   3 genar  staff    96 Nov 18 09:00 ..',
        '-rw-r--r--   1 genar  staff  2048 Nov 18 10:30 README.md',
        '-rwxr-xr-x   1 genar  staff  1024 Nov 18 10:15 main.js',
        'genar@terminal:~$ echo "Hello World"',
        'Hello World',
        'genar@terminal:~$ _'
      ];

      sampleText.forEach((line, i) => {
        ctx.fillText(line, 20, 30 + i * 25);
      });

      if (Math.sin(Date.now() * 0.005) > 0) {
        ctx.fillRect(20 + sampleText[sampleText.length - 1].length * 9, 30 + (sampleText.length - 1) * 25 - 15, 8, 18);
      }

      this.terminalTexture.needsUpdate = true;
    }

    animate() {
      this.animationId = requestAnimationFrame(() => this.animate());

      // Update time uniform for animations
      if (this.screenMesh && this.screenMesh.material.uniforms) {
        this.screenMesh.material.uniforms.time.value = Date.now() * 0.001;
      }

      // Capture terminal content
      this.captureTerminal();

      // Render scene
      this.renderer.render(this.scene, this.camera);
    }

    handleResize() {
      if (!this.camera || !this.renderer) return;

      const aspect = window.innerWidth / window.innerHeight;
      this.camera.aspect = aspect;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
    }

    destroy() {
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
      }
      if (this.renderer) {
        this.renderer.dispose();
      }
    }
  }

  // Initialize when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    const convexScreen = new ConvexScreenEffect();
    convexScreen.init();

    // Handle window resize
    window.addEventListener('resize', () => {
      convexScreen.handleResize();
    });

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      convexScreen.destroy();
    });
  });
</script>

<style>
  .convex-screen-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 10;
    mix-blend-mode: screen;
  }

  #convex-screen-canvas {
    width: 100%;
    height: 100%;
    opacity: 0.8;
  }
</style>